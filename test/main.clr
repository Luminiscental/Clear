
// TODO: Actual tests !!!

// -----------------------------------------------
// Recursive and Higher Order Functions:

func makeFac() func(int) int {
    func fac(int n) int {
        if (n <= 0i) {
            return 1i;
        }
        return n * fac(n - 1i);
    }

    return fac;
}

print "10! = " + str(makeFac()(10i));
print;

// -----------------------------------------------
// Optional Types:

struct LinkedListInt {
    int value,
    LinkedListInt? next,

    func to_str() str {
        return str(value) + next? ", " + next.to_str() : "";
    }
}

val test = LinkedListInt {
    value=2i,
    next=LinkedListInt {
        value=3i,
        next=LinkedListInt {
            value=-1i,
            next=LinkedListInt {
                value=7i,
                next=nil
            }
        }
    }
};

print "List: " + test.to_str();
print;

// -----------------------------------------------
// Method Closures:

{
    var counter = 0i;

    struct Incrementor {
        func act() void {
            counter = counter + 1i;
        }
    }

    struct Decrementor {
        func act() void {
            counter = counter - 1i;
        }
    }

    func displayCounter() void {
        print "counter = " + str(counter);
    }

    val inc = Incrementor {};
    val dec = Decrementor {};

    displayCounter();

    print "inc.act();";
    inc.act();
    displayCounter();

    print "inc.act();";
    inc.act();
    displayCounter();

    print "dec.act();";
    dec.act();
    displayCounter();

    print;
}

// -----------------------------------------------
// First-class functions / struct usage e.t.c.

struct Timer {
    str blockName,
    num startTime,

    func endBlock() void {
        val endTime = clock();
        val dt = endTime - startTime;

        print "[" + blockName + "] Finished in " + str(dt) + "s";
    }
}


func startBlock(str name) Timer {
    return Timer {
        blockName=name,
        startTime=clock()
    };
}

val timer = startBlock("Event struct declaration");

struct Event {
    int type,
    int value
}

timer.endBlock();

val EVENT_TYPE_KEY = 0i;
val EVENT_TYPE_MOUSE = 1i;

val timer = startBlock("Make simple first callback");

func firstCallback(Event event) void {
    print "first!";
}

timer.endBlock();

func secondCallback(Event event) void {
    print "second!";
}

func keyHandler(Event event) void {
    if (event.type != EVENT_TYPE_KEY) {
        return;
    }

    print "Key Event: [" + str(event.value) + "]";
}

func mouseHandler(Event event) void {
    if (event.type != EVENT_TYPE_MOUSE) {
        return;
    }

    print "Mouse Event: [" + str(event.value) + "]";
}

val timer = startBlock("EventDispatcher struct declaration");

struct EventDispatcher {
    func(Event) void dispatch,

    func subscribe(func(Event) void subscriber) EventDispatcher {
        func combinedDispatch(Event event) void {
            dispatch(event);
            subscriber(event);
        }

        return EventDispatcher {
            dispatch=combinedDispatch
        };
    }
}

timer.endBlock();

val timer = startBlock("Make EventDispatcher with 4 subscribers");

val dispatcher = EventDispatcher { dispatch=firstCallback }
    .subscribe(secondCallback)
    .subscribe(keyHandler)
    .subscribe(mouseHandler);

timer.endBlock();

val testEvent = Event { type=EVENT_TYPE_KEY, value=7i };

val timer = startBlock("Dispatch test event");

dispatcher.dispatch(testEvent);

timer.endBlock();

func dispatchMouseEvent(int value) void {
    val event = Event { type=EVENT_TYPE_MOUSE, value=value };
    dispatcher.dispatch(event);
}

func dispatchKeyEvent(int value) void {
    val event = Event { type=EVENT_TYPE_KEY, value=value };
    dispatcher.dispatch(event);
}

dispatchKeyEvent(3i);
dispatchMouseEvent(2i);
