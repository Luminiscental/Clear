
// TODO: Actual tests !!!

// var maybe_int int? = 3i;
// maybe_int = nil;

// -----------------------------------------------
// Recursive and Higher Order Functions:

func makeFac() func(int) int {

    func fac(int n) int {
        return if (n <= 0i) {
            1i
        } else {
            n * fac(n - 1i)
        };
    }

    return fac;
}

val fac = makeFac();

print "10! = " + str(fac(10i));
print;

// -----------------------------------------------
// Optional Types:

struct LinkedListInt {
    int value,
    LinkedListInt? next,

    func to_str() str {
        val dummy_list = LinkedListInt { value=0i, next=nil };
        val next_if_present = next?: dummy_list;

        // TODO: Handle unpacking of optional target in non-implicit present-case
        return str(value) + next? ", " + next_if_present.to_str() : "";
    }

    func push(int value) LinkedListInt {
        return LinkedListInt {
            value=value,
            next=this
        };
    }

    func for_each(func(int) void consume) void {
        val dummy_list = LinkedListInt { value=0i, next=nil };
        val next_if_present = next?: dummy_list;

        consume(value);
        next? next_if_present.for_each(consume);
    }
}

val testList = LinkedListInt { value=2i, next=nil }
    .push(3i)
    .push(-1i)
    .push(7i)
    .push(25i)
    .push(fac(7i))
    .push(-12i);

print "List: " + testList.to_str();

var sum = 0i;
func add_int(int x) void {
    sum = sum + x;
}

testList.for_each(add_int);
print "sum(List): " + str(sum);

print;

// -----------------------------------------------
// Method Closures:

{
    var counter = 0i;

    struct Incrementor {
        func act() void {
            counter = counter + 1i;
        }
    }

    struct Decrementor {
        func act() void {
            counter = counter - 1i;
        }
    }

    func displayCounter() void {
        print "counter = " + str(counter);
    }

    val inc = Incrementor {};
    val dec = Decrementor {};

    displayCounter();

    print "inc.act();";
    inc.act();
    displayCounter();

    print "inc.act();";
    inc.act();
    displayCounter();

    print "dec.act();";
    dec.act();
    displayCounter();

    print;
}

// -----------------------------------------------
// First-class functions / struct usage e.t.c.

struct Timer {
    str blockName,
    num startTime,

    func endBlock() void {
        val endTime = clock();
        val dt = endTime - startTime;

        print "[" + blockName + "] Finished in " + str(dt) + "s";
    }
}


func startBlock(str name) Timer {
    return Timer {
        blockName=name,
        startTime=clock()
    };
}

var timer = startBlock("Event struct declaration");

struct Event {
    int type,
    int value
}

timer.endBlock();

val EVENT_TYPE_KEY = 0i;
val EVENT_TYPE_MOUSE = 1i;

timer = startBlock("Make simple first callback");

func firstCallback(Event event) void {
    print "first!";
}

timer.endBlock();

func secondCallback(Event event) void {
    print "second!";
}

func keyHandler(Event event) void {
    if (event.type != EVENT_TYPE_KEY) {
        return;
    }

    print "Key Event: [" + str(event.value) + "]";
}

func mouseHandler(Event event) void {
    if (event.type != EVENT_TYPE_MOUSE) {
        return;
    }

    print "Mouse Event: [" + str(event.value) + "]";
}

timer = startBlock("EventDispatcher struct declaration");

struct EventDispatcher {
    func(Event) void dispatch,

    func subscribe(func(Event) void subscriber) EventDispatcher {
        func combinedDispatch(Event event) void {
            dispatch(event);
            subscriber(event);
        }

        return EventDispatcher {
            dispatch=combinedDispatch
        };
    }
}

timer.endBlock();

timer = startBlock("Make EventDispatcher with 4 subscribers");

val dispatcher = EventDispatcher { dispatch=firstCallback }
    .subscribe(secondCallback)
    .subscribe(keyHandler)
    .subscribe(mouseHandler);

timer.endBlock();

val testEvent = Event { type=EVENT_TYPE_KEY, value=7i };

timer = startBlock("Dispatch test event");

dispatcher.dispatch(testEvent);

timer.endBlock();

func dispatchMouseEvent(int value) void {
    val event = Event { type=EVENT_TYPE_MOUSE, value=value };
    dispatcher.dispatch(event);
}

func dispatchKeyEvent(int value) void {
    val event = Event { type=EVENT_TYPE_KEY, value=value };
    dispatcher.dispatch(event);
}

dispatchKeyEvent(3i);
dispatchMouseEvent(2i);
